val JAR_NAME =
  "ralph-lsp.jar"

val MAIN_CLASS =
  "org.alephium.ralph.lsp.Main"

val inliningOptions =
  Seq(
    "-opt-warnings",
    "-opt:l:inline",
    "-opt-inline-from:org.alephium.ralph.lsp.**"
    // Uncomment to debug inlining
    /*
    "-Yopt-log-inline",
    "_"
     */
  )

val commonSettings =
  Seq(
    organization := "org.alephium",
    scalaVersion := Version.scala213,
    scalacOptions ++=
      Seq(
        "-deprecation",
        "-encoding",
        "utf-8",
        "-explaintypes",
        "-feature",
        "-unchecked",
        // "-Xsource:3.1",
        "-Xfatal-warnings",
        "-Xlint:adapted-args",
        "-Xlint:constant",
        "-Xlint:delayedinit-select",
        "-Xlint:doc-detached",
        "-Xlint:inaccessible",
        "-Xlint:infer-any",
        "-Xlint:missing-interpolator",
        "-Xlint:nullary-unit",
        "-Xlint:option-implicit",
        "-Xlint:package-object-classes",
        "-Xlint:poly-implicit-overload",
        "-Xlint:private-shadow",
        "-Xlint:stars-align",
        "-Xlint:type-parameter-shadow",
        "-Xlint:nonlocal-return",
        "-Ywarn-dead-code",
        "-Ywarn-extra-implicit",
        "-Ywarn-numeric-widen",
        "-Ywarn-unused:implicits",
        "-Ywarn-unused:imports",
        "-Ywarn-unused:locals",
        "-Ywarn-unused:params",
        "-Ywarn-unused:patvars",
        "-Ywarn-unused:privates",
        "-Ywarn-value-discard"
      ) ++ inliningOptions,
    Compile / doc / scalacOptions ++= Seq(
      "-no-link-warnings"
    )
  )

lazy val `compiler-access` =
  project
    .settings(
      commonSettings,
      libraryDependencies ++=
        Seq(
          Dependencies.ralphc,
          Dependencies.scalaTest,
          Dependencies.scalaCheck,
          Dependencies.logback,
          Dependencies.scalaLogging
        )
    )

lazy val `presentation-compiler` =
  project
    .settings(
      commonSettings,
      libraryDependencies ++=
        Seq(
          Dependencies.ralphc,
          Dependencies.scalaTest,
          Dependencies.scalaCheck,
          Dependencies.scalaMock,
          Dependencies.logback,
          Dependencies.scalaLogging
        )
    )
    .dependsOn(`compiler-access` % "test->test;compile->compile")

/** Copies the JAR generated by assembly to VSCode's out directory */
lazy val copyJARToVSCode =
  taskKey[Unit](s"Copy $JAR_NAME to VSCode")

lazy val `lsp-server` =
  project
    .settings(
      commonSettings,
      scalacOptions += "-Xmixin-force-forwarders:false", // duplicate RPC method initialized.
      assembly / mainClass       := Some(MAIN_CLASS),
      assembly / assemblyJarName := JAR_NAME,
      assemblyMergeStrategy := {
        case PathList("module-info.class")        => MergeStrategy.discard
        case x if x.endsWith("module-info.class") => MergeStrategy.discard
        case other                                => assemblyMergeStrategy.value(other)
      },
      copyJARToVSCode :=
        IO.copyFile(
          sourceFile = (Compile / target).value / s"scala-${scalaBinaryVersion.value}" / JAR_NAME,
          targetFile = file(s"plugin-vscode/out/$JAR_NAME")
        ),
      Test / scalacOptions += "-Xmixin-force-forwarders:true", // reset to default for tests.
      libraryDependencies ++=
        Seq(
          Dependencies.lsp4j,
          Dependencies.scalaTest,
          Dependencies.scalaCheck,
          Dependencies.scalaMock,
          Dependencies.logback,
          Dependencies.scalaLogging
        )
    )
    .dependsOn(`presentation-compiler` % "test->test;compile->compile")

lazy val `ralph-lsp` =
  (project in file("."))
    .settings(
      commonSettings,
      Compile / mainClass := Some(MAIN_CLASS)
    )
    .dependsOn(`lsp-server`)
    .aggregate(`compiler-access`, `presentation-compiler`, `lsp-server`)
    .enablePlugins(JavaAppPackaging)

lazy val downloadWeb3AndInstallStd = taskKey[Unit]("Download alephium-web3 source code and copy std interface to the correct resource folder")

downloadWeb3AndInstallStd := {
  val web3Dir    = new File(s"target/web3/alephium-web3-${Version.web3}")
  val stdDir     = new File("compiler-access/src/main/resources/std")
  val web3StdDir = new File(s"target/web3/alephium-web3-${Version.web3}/packages/web3/std")

  if (java.nio.file.Files.notExists(web3Dir.toPath())) {
    IO.unzipURL(new URL(s"https://github.com/alephium/alephium-web3/archive/refs/tags/v${Version.web3}.zip"), new File("target/web3"))
  }

  IO.copyDirectory(web3StdDir, stdDir)
}

//Download and install of web3 will always be performed before compilation
Compile / compile := ((Compile / compile) dependsOn downloadWeb3AndInstallStd).value
